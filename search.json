[
  {
    "objectID": "results.html",
    "href": "results.html",
    "title": "Results",
    "section": "",
    "text": "Overall, our project was a success! We were able to meet our specs that we laid out in our proposal, and produced a system that let people arm wrestle with EMG sensors.\nThe system overall updates at a frequency of ~1 Hz. This is almost entirely due to the delay chosen in our main.c loop, as the time to read in the ADC channels (2 channels at 16 MHz taking 24.5 cycles each = 3 \\(\\mu\\) s), send the SPI signal (&gt; 10 \\(\\mu\\) s), and loop through the 512 pixels (36 counts at 1.5 MHz per pair times 8 pairs = 192 $$s) is negligable compared to the 1 full second delay. This amount of latency makes for good gameplay, as players can react to the progress shown before the game is won or lost.\nOur sensors were acting up on demo day, which was partly due to inoptimal quality of sensor pads and partly due to an amplifier design that didn’t have enough flexibility. We know it was the sensors and not the ADC because we checked our ADC setup with potentiometers and it worked perfectly."
  },
  {
    "objectID": "results.html#summary",
    "href": "results.html#summary",
    "title": "Results",
    "section": "",
    "text": "Overall, our project was a success! We were able to meet our specs that we laid out in our proposal, and produced a system that let people arm wrestle with EMG sensors.\nThe system overall updates at a frequency of ~1 Hz. This is almost entirely due to the delay chosen in our main.c loop, as the time to read in the ADC channels (2 channels at 16 MHz taking 24.5 cycles each = 3 \\(\\mu\\) s), send the SPI signal (&gt; 10 \\(\\mu\\) s), and loop through the 512 pixels (36 counts at 1.5 MHz per pair times 8 pairs = 192 $$s) is negligable compared to the 1 full second delay. This amount of latency makes for good gameplay, as players can react to the progress shown before the game is won or lost.\nOur sensors were acting up on demo day, which was partly due to inoptimal quality of sensor pads and partly due to an amplifier design that didn’t have enough flexibility. We know it was the sensors and not the ADC because we checked our ADC setup with potentiometers and it worked perfectly."
  },
  {
    "objectID": "results.html#gallery",
    "href": "results.html#gallery",
    "title": "Results",
    "section": "Gallery",
    "text": "Gallery\n Demonstration of FPGA and MCU properly displaying a controlled voltage input from two potentiometers, which are in place of the muscle sensors\n Multiplayer mode in full display, as two fellow MicroPs students (Ket and Jason) wrestle under disco lights"
  },
  {
    "objectID": "results.html#future-work",
    "href": "results.html#future-work",
    "title": "Results",
    "section": "Future Work",
    "text": "Future Work\nIf we were to continue working on this project, it would be good to better characterize the EMG sensor outputs. We noticed as we were demoing the project that the amplification circuit worked well for Ellie, but not Daniel, presumably due to different resting skin voltages. Instead of a fixed 11k resistor on the instrumentation amp, we could have a 1k in series with a 10k potentiometer, letting us vary the gain from 10x-100x. Also, we could make a PCB for it so we have fewer connection issues (or, we could just buy the commercial version). For the MCU, it would have been cleaner to use interrupts for the ADC instead of a timer. Also, it would have been nice to test and use the offset calculation function we started working on (which could additionally be used to enable a cheating mode if we wanted to put a finger on the scale).\nThe design of the FPGA could be improved. After the SPI module, single and multiplayer processes are run in parallel and then multiplexed before the system output, however this multiplex could also be done earlier to reduce processing power. Another area of improvement is to write modules to individual select a single pixel and set it to a desired rgb value, which would allow for much more flexibility in the screens capability. For the purpose of our project, we did not need this funcionality."
  },
  {
    "objectID": "midpoint.html",
    "href": "midpoint.html",
    "title": "Midpoint Status Memo",
    "section": "",
    "text": "Figure 1: Block diagram of the entire system, indicating progress\n\n\n\nAt the midpoint, we are ready to demo our breadboarded EMG sensor and our MCU code, including both the ADC and the SPI peripherals."
  },
  {
    "objectID": "midpoint.html#overview",
    "href": "midpoint.html#overview",
    "title": "Midpoint Status Memo",
    "section": "",
    "text": "Figure 1: Block diagram of the entire system, indicating progress\n\n\n\nAt the midpoint, we are ready to demo our breadboarded EMG sensor and our MCU code, including both the ADC and the SPI peripherals."
  },
  {
    "objectID": "midpoint.html#sensor",
    "href": "midpoint.html#sensor",
    "title": "Midpoint Status Memo",
    "section": "Sensor",
    "text": "Sensor\n\n\n\n\n\n\nFigure 2: Map of which electrode goes where on the 3.5mm jack\n\n\n\n\n\n\n\n\n\nFigure 3: A benchtop power supply supplies the +5V and -5V rails. The three electrodes have alligator clips running from the 3.5mm jack to the instrumentation amp.\n\n\n\nWe took inspiration from, but did not fully use, this schematic from a commercial MYG sensor that was out of our budget. This was good for the budget but bad for our time management as we ran into several issues.\n\n\n\n\n\n\nFigure 4: Our modified schmatic\n\n\n\nFirst, when we substitued a different instrumentation amp (the AD623) because we did not have the original schmatic part in the stockroom, we saw a large DC offset. This came from the large resistor we had between reference and ground, which was incorrect and made reference float slightly. We fixed it by connecting it directly to ground. Also, the decoupling capacitor that was meant to remove the DC offset removed the whole signal, so we removed the capacitor. We kept the high pass filter because it was already built into the circuit, and the full wave rectifier because we need it to protect the pins of the MCU. We discarded the rest of the circuit after the rectification because we needed to prioritze the rest of the digital design, not the analog sensor circuits. In total, we kept the instrumentation amplifier stage (with AD623), the inverting amplifier stage, and the full wave rectification stage.\n\n\n\n\n\n\n\nFigure 5: A representative flexing signal. The test subject flexed three times.\n\n\n\nThe physical connection to the ADC could be improved for robustness for demo day, but the signal is readable. The signal from a flexed bicep (Ellie’s bicep, to be specific) is in the neighborhood of 1 volt net change. This signal could be increased by having slightly larger gains in the amplifiers, but it will be easily read by the ADC."
  },
  {
    "objectID": "midpoint.html#mcu",
    "href": "midpoint.html#mcu",
    "title": "Midpoint Status Memo",
    "section": "MCU",
    "text": "MCU\n\nDesign\n\n\n\n\n\n\nFigure 6: Graphic showing how the signals flow in the MCU\n\n\n\nThe ADC was our new peripheral for the project, and its device driver is complete and functional. After initializing, ADC1 reads in channels 10 and 11 from pins PA5 and PA6. These will be players 1 and 2 respectively. Each time that the data register is read, the 16 bit data register is stored in a volatile uint_16t. The 16 bits are converted into two characters (8 bits) each, which are stored in an array via a pointer.\nThe other peripheral in use is the SPI peripheral. A pointer to the char array that the ADC populates is passed into a modified version of the lab 7 SPI code. It sends the 4 chars to the FPGA in the order MSB1, LSB1, MSB2, LSB2.\n\n\n\nTesting\n\n\n\n\n\n\nFigure 7: SPI from the MCU to the FPGA.\nD0 - CS, D1 - MOSI, D2 - MISO, D3 - SCK, D4 - LOAD\n\n\n\nAs seen in Figure 7, the ADC reads in the values and then the SPI peripheral sends them out. In addition to the regular SPI signals, there is also a load signal that we will use later to tell the FPGA when to shift in new data."
  },
  {
    "objectID": "midpoint.html#fpga",
    "href": "midpoint.html#fpga",
    "title": "Midpoint Status Memo",
    "section": "FPGA",
    "text": "FPGA\n\nDesign\n\n\n\n\n\n\nFigure 8: Block diagram of the FPGA and LED matrix\n\n\n\nWe have designed and started implementation of the FPGA, but it is not yet functional. The design for our first demo_top module is shown in Figure 8. The module that shifts in the SPI data was modified from aes_spi from Lab 7. However, we don’t need to send anything back to the MCU, so SDO will shift out nonsense. Because we intended to only use 12 bits of the received data because our resolution is only 12 bits, all our ports were sized for 12 bits, not 16. This is easily corrected in the top module. The single module has an FSM to determine which screen to show based on who is currently winning and who has been winning most recently. The current setup uses a demo_display module takes that screen and converts it into a simple led bar to show a coarse resolution. This is a temporary setup that will be replaced soon with the full LED matrix module."
  },
  {
    "objectID": "midpoint.html#appendix",
    "href": "midpoint.html#appendix",
    "title": "Midpoint Status Memo",
    "section": "Appendix",
    "text": "Appendix\nAll our MCU and FPGA code for this project can be found on our Github repo."
  },
  {
    "objectID": "documentation.html",
    "href": "documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "To build this game, use the files on our project Github."
  },
  {
    "objectID": "documentation.html#bill-of-materials",
    "href": "documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\n\n\nPart\nPart Number\nVendor\nQuantity\nPrice\nLink\n\n\n\n\nEMG Cables\nCAB-12970\nDigikey\n2\n11.38\nlink\n\n\nEMG Pads, 20 pack\nB007MA4RKU\nAmazon\n1\n8\nlink\n\n\nAD 623 Instrumentation Amplifier\nAD623\nHMC Stockroom\n2\n0\nn/a\n\n\nTL072 Op Amp\nTL072\nHMC Stockroom\n4\n0\nn/a\n\n\nResistors, assorted\nn/a\nHMC Stockroom\n6x150k, 2x11k, 12x10k\n0\nn/a\n\n\n1N4148 Diode\n1N4148\nHMC Stockroom\n4\n0\nn/a\n\n\nMedium 16x32 RGB LED matrix panel - 6mm Pitch\n420\nAdafruit\n1\n24.95\nlink"
  },
  {
    "objectID": "documentation.html#build-photos",
    "href": "documentation.html#build-photos",
    "title": "Documentation",
    "section": "Build Photos",
    "text": "Build Photos\n\n\n\n\n\n\nFigure 1: 3D printed enclosure\n\n\n\n\n\n\n\n\n\nFigure 2: EMG sensors\n\n\n\n\n\n\n\n\n\nFigure 3: FPGA to LED matrix\n\n\n\n\n\n\n\n\n\nFigure 4: Packing things into the box"
  },
  {
    "objectID": "checkoff.html",
    "href": "checkoff.html",
    "title": "Checkoff",
    "section": "",
    "text": "Uses a custom EMG sensor\n\nWe built an analog circuit that amplifies the small electrical signals from a muscle into a range readable by the ADC. The circuit has three stages. First, it has an instrumentation amplifier that takes in the differential signal from the electrodes and turns it into a single-sided signal. Next, the single-sided signal is amplified by a sequence of inverting amplifiers. Finally, the signal is rectified into something suitable for the ADC.\n\n\n\n\n\n\nFigure 1: A representative flexing signal. The test subject flexed three times.\n\n\n\n\nDevice driver for ADC peripheral written\n\nWe used a new peripheral for the STM32L432KC microcontroller, the Analog-to-Digital Converter or ADC. We wrote a new library for this sensor that provides initialization and read functions. The ADC gets the system clock with a prescaler of 8 so that it runs at 10 MHz. This\n\nSPI interface between MCU and FPGA\n\nWe reused a previous peripheral, the Serial Peripheral Interface (SPI), to communicate information from the MCU to the FPGA. On the MCU side, the SPI library function sendPlayerData sends 4 characters (upper and lower halves of each of the 12-bit voltages) and asserts a load signal. On the FPGA side, receive_only_SPI reads in the voltages based on the load signal and holds them when load is not asserted.\n\n\n\n\n\n\nFigure 2: SPI from the MCU to the FPGA.\nD0 - CS, D1 - MOSI, D2 - MISO, D3 - SCK, D4 - LOAD\n\n\n\n\nDrives LED matrix\n\nWe use a counter to loop through all 8 pairs of rows (given by abcstate). From 0 to 31, we load in rgb data. From 32 to 24, lat is asserted. From 34 to 36, output enable is asserted to turn off the screen as we move to the next row.At 36, counter resets and abcstate increments.\n\nSingle player and multiplayer modes\n\nSingle player mode (Figure 3) can be switched to show either player’s data as a bar chart. Multiplayer mode (Figure 4) shows two competing bars, red and blue, to indicate the game progress. In single player mode , a decoder converts the data into chunks. In multiplayer mode, a decoder compares the two voltages and outputs the state of the game. We mux between their outputs (which are really states, but that we call screens) based on a mode switch.\n\n\n\n\n\n\nFigure 3: Single player\n\n\n\n\n\n\n\n\n\nFigure 4: Multiplayer game\n\n\n\n\nGame effects, e.g. loading screen and victory screens\n\nThere are additional states that don’t display player data. They read in static .txt files to display more complex shapes, such as words. The victory screen also flashes to grab attention.\n\n\n\n\n\n\nFigure 5: Starting sequence, culminating with a GO!\n\n\n\n\n\n\n\n\n\nFigure 6: Victory for Player 1"
  },
  {
    "objectID": "checkoff.html#specs",
    "href": "checkoff.html#specs",
    "title": "Checkoff",
    "section": "",
    "text": "Uses a custom EMG sensor\n\nWe built an analog circuit that amplifies the small electrical signals from a muscle into a range readable by the ADC. The circuit has three stages. First, it has an instrumentation amplifier that takes in the differential signal from the electrodes and turns it into a single-sided signal. Next, the single-sided signal is amplified by a sequence of inverting amplifiers. Finally, the signal is rectified into something suitable for the ADC.\n\n\n\n\n\n\nFigure 1: A representative flexing signal. The test subject flexed three times.\n\n\n\n\nDevice driver for ADC peripheral written\n\nWe used a new peripheral for the STM32L432KC microcontroller, the Analog-to-Digital Converter or ADC. We wrote a new library for this sensor that provides initialization and read functions. The ADC gets the system clock with a prescaler of 8 so that it runs at 10 MHz. This\n\nSPI interface between MCU and FPGA\n\nWe reused a previous peripheral, the Serial Peripheral Interface (SPI), to communicate information from the MCU to the FPGA. On the MCU side, the SPI library function sendPlayerData sends 4 characters (upper and lower halves of each of the 12-bit voltages) and asserts a load signal. On the FPGA side, receive_only_SPI reads in the voltages based on the load signal and holds them when load is not asserted.\n\n\n\n\n\n\nFigure 2: SPI from the MCU to the FPGA.\nD0 - CS, D1 - MOSI, D2 - MISO, D3 - SCK, D4 - LOAD\n\n\n\n\nDrives LED matrix\n\nWe use a counter to loop through all 8 pairs of rows (given by abcstate). From 0 to 31, we load in rgb data. From 32 to 24, lat is asserted. From 34 to 36, output enable is asserted to turn off the screen as we move to the next row.At 36, counter resets and abcstate increments.\n\nSingle player and multiplayer modes\n\nSingle player mode (Figure 3) can be switched to show either player’s data as a bar chart. Multiplayer mode (Figure 4) shows two competing bars, red and blue, to indicate the game progress. In single player mode , a decoder converts the data into chunks. In multiplayer mode, a decoder compares the two voltages and outputs the state of the game. We mux between their outputs (which are really states, but that we call screens) based on a mode switch.\n\n\n\n\n\n\nFigure 3: Single player\n\n\n\n\n\n\n\n\n\nFigure 4: Multiplayer game\n\n\n\n\nGame effects, e.g. loading screen and victory screens\n\nThere are additional states that don’t display player data. They read in static .txt files to display more complex shapes, such as words. The victory screen also flashes to grab attention.\n\n\n\n\n\n\nFigure 5: Starting sequence, culminating with a GO!\n\n\n\n\n\n\n\n\n\nFigure 6: Victory for Player 1"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Us",
    "section": "",
    "text": "Ellie is a senior engineering major. She is in MicroPs because she has an interest in embedded systems as they apply to robotics. After graduation, she plans to work as an electrical engineer in the aerospace/space exploration sector.\nDaniel is a senior engineering major. He took MicroPs to explore the world of embedded systems because of his interest in its intersection between firmware and software. He plans to work as a signals engineer for HigherGround after graduation."
  },
  {
    "objectID": "design.html",
    "href": "design.html",
    "title": "Design",
    "section": "",
    "text": "Figure 1: Block diagram of the final system\n\n\n\nFigure 1 shows the overall system block diagram. The system begins with two amplified signals from the muscle sensors, which is input into the MCU as two analog signals. The MCU then converts the signals into a concatenated 32-bit digital signals and sends the data across SPI to the FPGA. The FPGA reads the SPI signal and contains modules to determine both players’ data and displays them on the LED display through a FSM module that converts a desired screen display into the correct output pins for interfacing with the display matrix. The display matrix interprets the output signals sequentially at a frequency of 1.5MHz to display the screen.\n\n\n\n\n\n\nFigure 2: The full system schematic"
  },
  {
    "objectID": "design.html#overview",
    "href": "design.html#overview",
    "title": "Design",
    "section": "",
    "text": "Figure 1: Block diagram of the final system\n\n\n\nFigure 1 shows the overall system block diagram. The system begins with two amplified signals from the muscle sensors, which is input into the MCU as two analog signals. The MCU then converts the signals into a concatenated 32-bit digital signals and sends the data across SPI to the FPGA. The FPGA reads the SPI signal and contains modules to determine both players’ data and displays them on the LED display through a FSM module that converts a desired screen display into the correct output pins for interfacing with the display matrix. The display matrix interprets the output signals sequentially at a frequency of 1.5MHz to display the screen.\n\n\n\n\n\n\nFigure 2: The full system schematic"
  },
  {
    "objectID": "design.html#sensor",
    "href": "design.html#sensor",
    "title": "Design",
    "section": "Sensor",
    "text": "Sensor\nAn EMG sensor detects electrical activity in muscles via a conductive pad on the skin. Electrical signals on the skin are typically between 50μV to 30mV, depending on the quality of the electrode pads and the individual. An EMG sensor amplifies this signal with a gain between ~33x to 100000x and outputs an analog signal.\nWe took inspiration from, but did not fully use, a commercial MYG sensor that was out of our budget. We substituted a different instrumentation amp (AD623) because we did not have the original schematic part in the stockroom. We also removed the decoupling capacitor that was meant to remove the DC offset becasue it removed the whole signal. We kept the high pass filter because it was already built into the circuit, and the full wave rectifier because we need it to protect the pins of the MCU. We discarded the rest of the circuit after the rectification."
  },
  {
    "objectID": "design.html#mcu",
    "href": "design.html#mcu",
    "title": "Design",
    "section": "MCU",
    "text": "MCU\n\n\n\n\n\n\nFigure 3: Graphic showing how the signals flow in the MCU\n\n\n\nThe Analog-to-Digital Converter (ADC) was our new peripheral for the project. After initializing, ADC1 reads in channels 10 and 11 from pins PA5 and PA6, which are players 1 and 2 respectively. Each time that the data register is read, the 16 bit data register is stored in a volatile uint_16t. Because resolution is set to 12 bits (the max), the 16 bit data register has 4 extra zeros at the top. It is easy to get rid of them inside the FPGA, and 16 bits divides nicely into 2 characters of 8 bits each, which is the size of a SPI transaction. The characters are stored in an array via a pointer.\nThe other peripheral in use is the SPI peripheral. A pointer to the char array that the ADC populates is passed into a modified version of the lab 7 SPI code. It sends the 4 chars to the FPGA in the order MSB1, LSB1, MSB2, LSB2.\n\n\n\n\n\n\n\nFigure 4: SPI from the MCU to the FPGA.\nD0 - CS, D1 - MOSI, D2 - MISO, D3 - SCK, D4 - LOAD\n\n\n\nAs seen in Figure 4, the ADC reads in the values and then the SPI peripheral sends them out. In addition to the regular SPI signals, there is also a load signal that we use to tell the FPGA when to shift in new data."
  },
  {
    "objectID": "design.html#fpga",
    "href": "design.html#fpga",
    "title": "Design",
    "section": "FPGA",
    "text": "FPGA\n\n\n\n\n\n\nFigure 5: Block diagram of the FPGA and LED matrix\n\n\n\nThe design for our FPGA is contained in our top module, which is shown in Figure 5. The FPGA design contains a SPI recieve module, two modules for selecting the screen (in single player or multiplayer mode), two modules which interface the selected screen into output pins for the LED matrix, and a multiplex which selects the set of output pins based on the player mode. The module that shifts in the SPI data was modified from aes_spi from Lab 7. However, we don’t need to send anything back to the MCU, so SDO will shift out nonsense. Because we intended to only use 12 bits of the received data because our resolution is only 12 bits, all our ports were sized for 12 bits, not 16. This is easily corrected in the top module.\nOnce the digital signal is recieved from the SPI module, the single and multiplayer processes are very similar. The single module is an asyncrhonous module, which outputs a 6-bit value for the screen state depending on the input of 1 player’s digital signal magnitude. The multi module is a synchronous module, which also outputs a screen value, but is determined by which players’ digital signal magnitude is greater. The multi module also has some preset screen matrices for winning screens and a start sequence, saved as .txt files.\nIn the singleplayer pipeline, the 6-bit screen state value is fed to the singledisplay module, alongside the same system clock and reset. Inside this synchronous module, the screen state corresponds directly to the magnitude of the signal and so that value is assigned to a new variable called barrier. This barrier variable denotes which pixels should be lit up, with pixels to the left of it being red and pixels the right being off, to emulate the bar filling effect when flexing harder. The module also writes the entire border as green and contains a\na row above and below the red bar to be off to create a more stark contrast.\nIn the multiplayer pipeline, the multipdisplay module functions very similar. It is also synchronous, and takes in a new set of 21 screen states. Again, the barrier method is used for the first 15 screen states, with pixels left of the barrier being red, and pixels to the right being blue. Similar border and buffer rows are written again as well. The multidisplay module has an additional six screen states for the start sequence and player winning screens. These screens are created using text files with a 16x32 matrix of 1s and 0s to mark whether the pixel is on or off. These text files are read sequentially and the appropriately mapped pixel is on for 1 and off for 0. Because the display is capable of rgb, this method restricts the leds to just one color.\nTo correctly interface with the LED display, the singledisplay and multidisplay modules we need to output two sets of 3-bit rgb values, a 3-bit abc value to select the row in the matrix, a latch, an output enable, and a clk. The matrix works by sequentially turning on two pixels at a time on each clock pulse. The two rows are selected by A, B, and C inputs which map to values 0-7, with 0 selecting rows 0 and 8, 1 selecting rows 1 and 9, etc. R1, G1, and B1 select the color of the top row, while R2, G2, and B2 select the color of the bottom. Because there are 32 bits, clk will run for a few cycles longer then latch it with the lat signal. The output enable signal will be held high until the latch is triggered, and then the next row will be written. We have the clk pulsing at a frequency of 1.5 MHz so the screen is written much faster than the human eye can detect. At this frequency, the entire screen is written every 0.192ms or at a frequency of 5.2 kHz (36 pixels per row * 16 rows per screen / 2 rows written per row state all at a frequency of 1.5MHz). Some issues did arrive with higher frequencies, as the clock signal began to bleed.\n\nTesting\n\n\n\n\n\n\nFigure 6: Testbench of single module\n\n\n\n\n\n\n\n\n\nFigure 7: Testbench of singledisplay module: view of one row\n\n\n\n\n\n\n\n\n\nFigure 8: Testbench of singledisplay module: view of one screen\n\n\n\nTesting the single player mode began with ensuring that the correct screen state was output. The testbench seen in Figure 6 demonstrates this with 12-bit digital signals between 0 and 3.3 corresponding to their correct screen value.\nThe singledisplay module was a little trickier, but Figure 7 shows the testbench zoomed in to show the clock cycling through the first row state in screen state 3. As seen, rbg for row 0 is consistently 010, so that the upper border is green. Then the rgb for row 8, which is in the middle of the screen is 100 for the first few cycles (state 3 corresponds to a bar that is roughly 4/16 full) and 000 after (when the counter is to the right of the barrier variable). This view also shows output enable being high until the row is switched and lat pulsing once the 32 bits have been written.\nFigure 8 shows the testbench, zoomed out to show abc cycling through for a whole screen. For each of the seven abc states, the same process is seen, with rgb values being written for each individual pixel and changes to lat and oe marking the end of the row.\n\n\n\n\n\n\nFigure 9: Testbench of multi module\n\n\n\n\n\n\n\n\n\nFigure 10: Testbench of multidisplay module: view of one row\n\n\n\n\n\n\n\n\n\nFigure 11: Testbench of multidisplay module: view of one screen\n\n\n\nThe simulations for multiplayer mode follow a similar process. Figure 9 shows the desired screen being output after reset. Because this mode is sequential, the first four screens are the preset start sequence, and the state changes every 0.715 Hz (a higher frequency is set for the simulation). After the start sequence, the state increases or decreases depending on which player data is a greater magnitude. Once a player reaches the winning state, that state is held until reset.\nFigure 10 is very similar to the testbench seen in singledisplay but also shows multidisplay at a zoomed in view to show clk cycling through for a whole row.\nSimilarily, Figure 11 shows a testbench of multidisplay zoomed in to show abc cycling through its seven states to light the whole screen.\n\n\nDiscussion\nAfter the SPI module, single and multiplayer processes are run in parallel and then multiplexed before the system output, however this multiplex could also be done earlier to reduce processing power."
  },
  {
    "objectID": "design.html#box",
    "href": "design.html#box",
    "title": "Design",
    "section": "Box",
    "text": "Box\nWe designed a 3D printed box (Figure 12) to hide and protect all the wires and breadboards. It is a friction fit with the LED matrix on the front. The sensor breadboard goes on the shelf, and the microPs board and breakout go on the bottom. Power enters through the back and sensor wires enter through the sides.\n\n\n\n\n\n\nFigure 12: CAD drawing of part (stl file is in Github)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-Free Arm Wrestling",
    "section": "",
    "text": "Ever wanted to arm wrestle, but without actually having to arm wrestle? Look no further! Our project measures the electrical signals on your skin with an EMG sensor, and uses that to control a miniature arm wrestling game. When you (and a friend) flex, the electrical signals from your nerves that tell your muscles to contract get picked up by the sticky electrodes and sent into a circuit that amplifies them so that they are big enough to measure with the analog-to-digital converter on a STM32L432KC microcontroller. The microcontroller then sends the signals to the Upduino 3.1, a field-programmable gate array (FPGA). The FPGA controls the LED matrix that displays the game. It has two modes, single and multiplayer. Selecting single player displays the raw signal as a bar chart. Selecting multiplayer displays two competing bars, and updates the relative size of each depending on how hard you flex. Getting your color to cover the entire screen means victory!"
  },
  {
    "objectID": "index.html#new-hardware",
    "href": "index.html#new-hardware",
    "title": "Hands-Free Arm Wrestling",
    "section": "New Hardware",
    "text": "New Hardware\n\nEMG Sensors (x2) - These sensors measure electrical activity on the skin and amplify it to an analog signal.\nLED Matrix 32x16 (x1) - This display has 512 RGB LEDs and is controllable from the FPGA."
  },
  {
    "objectID": "index.html#specifications",
    "href": "index.html#specifications",
    "title": "Hands-Free Arm Wrestling",
    "section": "Specifications",
    "text": "Specifications\nFor this project, the team will…\n\nBuild a custom EMG sensor\nWrite a device driver for ADC peripheral\nImplement a SPI interface between MCU and FPGA\nDrive the LED matrix\nHave single player and multiplayer modes\nHave game effects, e.g. loading screen and victory screens"
  },
  {
    "objectID": "index.html#video",
    "href": "index.html#video",
    "title": "Hands-Free Arm Wrestling",
    "section": "Video",
    "text": "Video"
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Hands-Free Arm Wrestling",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank Prof Brake for teaching E155 this semester! We would also like to thank Jacob in the stockroom for helping us find all the parts we needed, our E155 classmates for help and encouragement in the Digital Lab dungeon, and our friends for turning out to support on Demo Day!"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "The following links were helpful to us in our build process:\n\nInstructable for EMG Sensor This link explains how to build an earlier version of a sensor that we wanted to buy but was out of budget to this class. We got rid of the last few stages and swapped in the AD623 but mostly used this design.\nAD623 Datasheet\nLED Matrix Datasheet"
  }
]